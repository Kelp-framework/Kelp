{"name":"Kelp","tagline":"A web framework light, yet rich in nutrients.","body":"# SYNOPSIS\r\n\r\nFirst ...\r\n\r\n```perl\r\n# lib/MyApp.pm\r\npackage MyApp;\r\nuse parent 'Kelp';\r\n\r\nsub build {\r\n    my $self = shift;\r\n    my $r = $self->routes;\r\n    $r->add( \"/hello\", sub { \"Hello, world!\" } );\r\n    $r->add( '/hello/:name', 'greet' );\r\n}\r\n\r\nsub greet {\r\n    my ( $self, $name ) = @_;\r\n    \"Hello, $name!\";\r\n}\r\n\r\n1;\r\n```\r\n\r\nThen ...\r\n\r\n```perl\r\n# app.psgi\r\nuse MyApp;\r\nmy $app = MyApp->new;\r\n$app->run;\r\n```\r\n\r\nFinally ...\r\n\r\n```none\r\n> plackup app.psgi\r\n```\r\n\r\nOr, for quick prototyping use [Kelp::Less](http://search.cpan.org/perldoc?Kelp::Less):\r\n\r\n```perl\r\n# app.psgi\r\nuse Kelp::Less;\r\n\r\nget '/hello/?name' => sub {\r\n    my ( $self, $name ) = @_;\r\n    \"Hello \" . $name // 'world';\r\n};\r\n\r\nrun;\r\n```\r\n\r\n# DESCRIPTION\r\n\r\nIf you're going to be deploying a Perl based web application, chances are that\r\nyou will be using Plack. Plack has almost all necessary tools to create and\r\nmaintain a healthy web app. Tons of middleware is written for it, and there are\r\nseveral very well tested high performance preforking servers, such as Starman.\r\n\r\nPlack, however, is not a web framework, hence its creators have intentionally\r\nomitted adding certain components. This is where Kelp gets to shine. It provides\r\na layer on top of Plack and puts everything together into a complete web\r\nframework.\r\n\r\nKelp provides:\r\n\r\n- __Advanced Routing__. Create intricate, yet simple ways to capture HTTP requests\r\nand route them to their designated code. Use explicit and optional named\r\nplaceholders, wildcards, or just regular expressions.\r\n- __Flexible Configuration__. Use different configuration file for each\r\nenvironment, e.g. development, deployment, etc. Merge a temporary configuration\r\ninto your current one for testing and debugging purposes.\r\n- __Enhanced Logging__. Log messages at different levels of emergency. Log to a\r\nfile, screen, or anything supported by Log::Dispatcher.\r\n- __Powerful Rendering__. Use the built-in auto-rendering logic, or the template\r\nmodule of your choice to return rich text, html and JSON responses.\r\n- __JSON encoder/decoder__. If you're serious about your back-end code. Kelp comes\r\nwith JSON, but you can easily plug in JSON::XS or any decoder of your choice.\r\n- __Extendable Core__. Kelp uses pluggable modules for everything. This allows\r\nanyone to add a module for a custom interface. Writing Kelp modules is a\r\npleasant and fulfilling activity.\r\n- __Sleek Testing__. Kelp takes Plack::Test and wraps it in an object oriented\r\nclass of convenience methods. Testing is done via sending requests to your\r\nroutes, then analyzing the response.\r\n\r\n# WHY KELP?\r\n\r\nWhat makes Kelp different from the other Perl micro web frameworks? There are a\r\nnumber of fine web frameworks on CPAN, and most of them provide a complete\r\nplatform for web app building. Most of them, however, bring their deployment code,\r\nand aim to write their own processing mechanisms. Kelp, on the other hand, is heavily\r\n_Plack_\\-centric. It uses Plack as its foundation layer, and it builds the web\r\nframework on top of it. `Kelp::Request` is an extension of `Plack::Request`,\r\n`Kelp::Response` is an extension of `Plack::Response`.\r\n\r\nThis approach of extending current CPAN code puts familiar and well tested\r\ntools in the hands of the application developer, while keeping familiar syntax\r\nand work flow.\r\n\r\nKelp is a team player and it uses several popular, trusted CPAN modules for its\r\ninternals. At the same time it doesn't include modules that it doesn't need,\r\njust because they are considered trendy. It does its best to keep a lean profile\r\nand a small footprint, and it's completely object manager agnostic.\r\n\r\n# CREATING A NEW WEB APP\r\n\r\n## Using the `Kelp` script\r\n\r\nThe easiest way to create the directory structure and a general application\r\nskeleton is by using the `Kelp` script, which comes with this package.\r\n\r\n```none\r\n> Kelp MyApp\r\n```\r\n\r\nThis will create `lib/MyApp.pm`, `app.psgi` and some other files (explained\r\nbelow).\r\n\r\nTo create a [Kelp::Less](http://search.cpan.org/perldoc?Kelp::Less) app, use:\r\n\r\n```none\r\n> Kelp --less MyApp\r\n```\r\n\r\nGet help by typing:\r\n\r\n```none\r\n> Kelp --help\r\n```\r\n\r\n## Directory structure\r\n\r\nBefore you begin writing the internals of your app, you need to create the\r\ndirectory structure either by hand, or by using the above described `Kelp`\r\nutility script.\r\n\r\n```none\r\n .\r\n |--/lib\r\n |   |--MyApp.pm\r\n |   |--/MyApp\r\n |\r\n |--/conf\r\n |   |--config.pl\r\n |   |--test.pl\r\n |   |--development.pl\r\n |   |--deployment.pl\r\n |\r\n |--/view\r\n |--/log\r\n |--/t\r\n |--app.psgi\r\n```\r\n\r\n- __/lib__\r\n\r\n    The `lib` folder contains your application modules and any local modules\r\n    that you want your app to use.\r\n\r\n- __/conf__\r\n\r\n    The `conf` folder is where Kelp will look for configuration files. You need one\r\n    main file, named `config.pl`. You can also add other files that define different\r\n    running environments, if you name them _environment_`.pl`. Replace\r\n    _environment_ with the actual name of the environment.\r\n    To change the running environment, you can specify the app `mode`, or you can\r\n    set the `PLACK_ENV` environment variable.\r\n\r\n    ```perl\r\n    my $app = MyApp->new( mode => 'development' );\r\n```\r\n\r\n    or\r\n\r\n    ```none\r\n    > PLACK_ENV=development plackup app.psgi\r\n```\r\n\r\n- __/view__\r\n\r\n    This is where the `Template` module will look for template files.\r\n\r\n- __/log__\r\n\r\n    This is where the `Logger` module will create `error.log`, `debug.log` and\r\n    any other log files that were defined in the configuration.\r\n\r\n- __/t__\r\n\r\n    The `t` folder is traditionally used to hold test files. It is up to you to use\r\n    it or not, although we strongly recommend that you write some automated test\r\n    units for your web app.\r\n\r\n- __app.psgi__\r\n\r\n    This is the [PSGI](http://search.cpan.org/perldoc?PSGI) file, of the app, which you will deploy. In it's most basic\r\n    form it should look like this:\r\n\r\n    ```perl\r\n    use lib '../lib';\r\n    use MyApp;\r\n\r\n    my $app = MyApp->new;\r\n    $app->run;\r\n```\r\n\r\n## The application classes\r\n\r\nYour application's classes should be put in the `lib/` folder. The main class,\r\nin our example `MyApp.pm`, initializes any modules and variables that your\r\napp will use. Here is an example that uses `Moose` to create lazy attributes\r\nand initialize a database connection:\r\n\r\n```perl\r\npackage MyApp;\r\nuse Moose;\r\n\r\nhas dbh => (\r\n    is      => 'ro',\r\n    isa     => 'DBI',\r\n    lazy    => 1,\r\n    default => sub {\r\n        my $self   = shift;\r\n        my @config = @{ $self->config('dbi') };\r\n        return DBI->connect(@config);\r\n    }\r\n);\r\n\r\nsub build {\r\n    my $self = shift;\r\n    $self->routes->add(\"/read/:id\", \"read\");\r\n}\r\n\r\nsub read {\r\n    my ( $self, $id ) = @_;\r\n    $self->dbh->selectrow_array(q[\r\n        SELECT * FROM problems\r\n        WHERE id = ?\r\n    ], $id);\r\n}\r\n\r\n1;\r\n```\r\n\r\nWhat is happening here?\r\n\r\n- First, we create a lazy attribute and instruct it to connect to DBI. Notice that\r\nwe have access to the current app and all of its internals via the `$self`\r\nvariable. Notice also that the reason we define `dbh` as a _lazy_ attribute\r\nis that `config` will not yet be initialized. All modules are initialized upon\r\nthe creation of the object instance, e.g. when we call `MyApp->new`;\r\n- Then, we override Kelp's [\"build\"](#build) subroutine to create a single route\r\n`/read/:id`, which is assigned to the subroutine `read` in the current class.\r\n- The `read` subroutine, takes `$self` and `$id` (the named placeholder from the\r\npath), and uses `$self->dbh` to retrieve data.\r\n\r\n_A note about object managers:_ The above example uses [Moose](http://search.cpan.org/perldoc?Moose). It is entirely\r\nup to you to use Moose, another object manager, or no object manager at all.\r\nThe above example will be just as successful if you used our own little\r\n[Kelp::Base](http://search.cpan.org/perldoc?Kelp::Base):\r\n\r\n```perl\r\npackage MyApp;\r\nuse Kelp::Base 'Kelp';\r\n\r\nattr dbi => sub {\r\n    ...\r\n};\r\n\r\n1;\r\n```\r\n\r\n## Routing\r\n\r\nKelp uses a powerful and very flexible router. Traditionally, it is also light\r\nand consists of less than 300 lines of code (comments included). You are\r\nencouraged to read [Kelp::Routes](http://search.cpan.org/perldoc?Kelp::Routes), but here are some key points. All examples\r\nare assumed to be inside the [\"build\"](#build) method and `$r` is equal to\r\n`$self->routes`:\r\n\r\n### Destinations\r\n\r\nYou can direct HTTP paths to subroutines in your classes or, you can use inline\r\ncode.\r\n\r\n```perl\r\n$r->add( \"/home\", \"home\" );  # goes to sub home\r\n$r->add( \"/legal\", \"legal#view\" ); # goes to MyApp::Legal::view\r\n$r->add( \"/about\", sub { \"Content for about\" }); # inline\r\n```\r\n\r\n### Restrict HTTP methods\r\n\r\nMake a route only catch a specific HTTP method:\r\n\r\n```perl\r\n$r->add( [ POST => '/update' ], \"update_user\" );\r\n```\r\n\r\n### Named captures\r\n\r\nUsing regular expressions is so Perl. Sometimes, however, it gets a little\r\noverwhelming. Use named paths if you anticipate that you or someone else will\r\never want to maintain your code.\r\n\r\n#### Explicit\r\n\r\n```perl\r\n$r->add( \"/update/:id\", \"update\" );\r\n\r\n# Later\r\nsub update {\r\n    my ( $self, $id ) = @_;\r\n    # Do something with $id\r\n}\r\n```\r\n\r\n#### Optional\r\n\r\n```perl\r\n$r->add( \"/person/?name\", sub {\r\n    my ( $self, $name ) = @_;\r\n    return \"I am \" . $name // \"nobody\";\r\n});\r\n```\r\n\r\nThis will handle `/person`, `/person/` and `/person/jack`.\r\n\r\n#### Wildcards\r\n\r\n```perl\r\n$r->add( '/*article/:id', 'articles#view' );\r\n```\r\n\r\nThis will handle `/bar/foo/baz/500` and send it to `MyApp::Articles::view`\r\nwith parameters `$article` equal to `bar/foo/baz` and `$id` equal to 500.\r\n\r\n### Placeholder restrictions\r\n\r\nPaths' named placeholders can be restricted by providing regular expressions.\r\n\r\n```perl\r\n$r->add( '/user/:id', {\r\n    check => { id => '\\d+' },\r\n    to    => \"users#get\"\r\n});\r\n\r\n# Matches /user/1000, but not /user/abc\r\n```\r\n\r\n### Placeholder defaults\r\n\r\nThis only applies to optional placeholders, or those prefixed with a question mark.\r\nIf a default value is provided for any of them, it will be used in case the\r\nplaceholder value is missing.\r\n\r\n```perl\r\n$r->add( '/:id/?other', defaults => { other => 'info' } );\r\n\r\n# GET /100;\r\n# { id => 100, other => 'info' }\r\n\r\n# GET /100/delete;\r\n# { id => 100, other => 'delete' }\r\n```\r\n\r\n### Bridges\r\n\r\nA _bridge_ is a route that has to return a true value in order for the next\r\nroute in line to be processed.\r\n\r\n```perl\r\n$r->add( '/users', { to => 'Users::auth', bridge => 1 } );\r\n$r->add( '/users/:action' => 'Users::dispatch' );\r\n```\r\n\r\nSee [\"BRIDGES\" in Kelp::Routes](http://search.cpan.org/perldoc?Kelp::Routes#BRIDGES) for more information.\r\n\r\n### URL building\r\n\r\nEach path can be given a name and later a URL can be built using that name and\r\nthe necessary arguments.\r\n\r\n```perl\r\n$r->add( \"/update/:id\", { name => 'update', to => 'user#update' } );\r\n\r\n# Later\r\n\r\nmy $url = $self->route->url('update', id => 1000); # /update/1000\r\n```\r\n\r\n## Quick development using Kelp::Less\r\n\r\nFor writing quick experimental web apps and to reduce the boiler plate, one\r\ncould use [Kelp::Less](http://search.cpan.org/perldoc?Kelp::Less). In this case all of the code can be put in `app.psgi`:\r\nLook up the POD for `Kelp::Less` for many examples, but to get you started off,\r\nhere is a quick one:\r\n\r\n```perl\r\n# app.psgi\r\nuse Kelp:::Less;\r\n\r\nget '/api/:user/?action' => sub {\r\n    my ( $self, $user, $action ) = @_;\r\n    my $json = {\r\n        success => \\1,\r\n        user    => $user,\r\n        action  => $action // 'ask'\r\n    };\r\n    return $json;\r\n};\r\n\r\nrun;\r\n```\r\n\r\n## Adding middleware\r\n\r\nKelp, being Plack-centric, will let you easily add middleware. There are three\r\npossible ways to add middleware to your application, and all three ways can be\r\nused separately or together.\r\n\r\n### Using the configuration\r\n\r\nAdding middleware in your configuration is probably the easiest and best way for\r\nyou. This way you can load different middleware for each running mode, e.g.\r\n`Debug` in development only.\r\n\r\nAdd middleware names to the `middleware` array in your configuration file and\r\nthe corresponding initializing arguments in the `middleware_init` hash:\r\n\r\n```perl\r\n# conf/development.pl\r\n{\r\n    middleware      => [qw/Session Debug/],\r\n    middleware_init => {\r\n        Session => { store => 'File' }\r\n    }\r\n}\r\n```\r\n\r\nThe middleware will be added in the order you specify in the `middleware`\r\narray.\r\n\r\n### In `app.psgi`:\r\n\r\n```perl\r\n# app.psgi\r\nuse MyApp;\r\nuse Plack::Builder;\r\n\r\nmy $app = MyApp->new();\r\n\r\nbuilder {\r\n    enable \"Plack::Middleware::ContentLength\";\r\n    $app->run;\r\n};\r\n```\r\n\r\n### By overriding the [\"run\"](#run) subroutine in `lib/MyApp.pm`:\r\n\r\nMake sure you call `SUPER` first, and then wrap new middleware around the\r\nreturned app.\r\n\r\n```perl\r\n# lib/MyApp.pm\r\nsub run {\r\n    my $self = shift;\r\n    my $app = $self->SUPER::run(@_);\r\n    Plack::Middleware::ContentLength->wrap($app);\r\n}\r\n```\r\n\r\nNote that any middleware defined in your config file will be added first.\r\n\r\n## Deploying\r\n\r\nDeploying a Kelp application is done the same way any other Plack application is\r\ndeployed:\r\n\r\n```none\r\n> plackup -E deployment -s Starman app.psgi\r\n```\r\n\r\n## Testing\r\n\r\nKelp provides a test class called `Kelp::Test`. It is object oriented, and all\r\nmethods return the `Kelp::Test` object, so they can be chained together.\r\nTesting is done by sending HTTP requests to an already built application and\r\nanalyzing the response. Therefore, each test usually begins with the\r\n[\"request\" in Kelp::Test](http://search.cpan.org/perldoc?Kelp::Test#request) method, which takes a single [HTTP::Request](http://search.cpan.org/perldoc?HTTP::Request) parameter.\r\nIt sends the request to the web app and saves the response as an\r\n[HTTP::Response](http://search.cpan.org/perldoc?HTTP::Response) object.\r\n\r\n```perl\r\n# file t/test.t\r\nuse MyApp;\r\nuse Kelp::Test;\r\nuse Test::More;\r\nuse HTTP::Request::Common;\r\n\r\nmy $app = MyApp->new( mode => 'test' );\r\nmy $t = Kelp::Test->new( app => $app );\r\n\r\n$t->request( GET '/path' )\r\n  ->code_is(200)\r\n  ->content_is(\"It works\");\r\n\r\n$t->request( POST '/api' )\r\n  ->json_cmp({auth => 1});\r\n\r\ndone_testing;\r\n```\r\n\r\nWhat is happening here?\r\n\r\n- First, we create an instance of the web application class, which we have\r\npreviously built and placed in the `lib/` folder. We set the mode of the app to\r\n`test`, so that file `conf/test.pl` overrides the main configuration.\r\nThe test configuration can contain anything you see fit. Perhaps you want to\r\ndisable certain modules, or maybe you want to make DBI connect to a different\r\ndatabase.\r\n- Second, we create an instance of the `Kelp::Test` class and tell it that it\r\nwill perform all tests using our `$app` instance.\r\n- At this point we are ready to send requests to the app via the\r\n[request](http://search.cpan.org/perldoc?Kelp::Test#request) method. It takes only one argument, an\r\nHTTP::Request object. It is very convenient to use the [HTTP::Request::Common](http://search.cpan.org/perldoc?HTTP::Request::Common)\r\nmodule here, because you can create common requests using abridged syntax,\r\ni.e. `GET`, `POST`, etc.  The line `$t->request( GET '/path' )` fist\r\ncreates a HTTP::Request GET object, and then passes it to the `request` method.\r\n- After we send the request, we can test the response using any of the `Test::`\r\nmodules, or via the methods provided by [Kelp::Test](http://search.cpan.org/perldoc?Kelp::Test).\r\nIn the above example, we test if we got a code 200 back from `/path` and if the\r\nreturned content was `It works`.\r\n\r\nRun the rest as usual, using `prove`:\r\n\r\n```none\r\n> prove -l t/test.t\r\n```\r\n\r\nTake a look at the [Kelp::Test](http://search.cpan.org/perldoc?Kelp::Test) for details and more examples.\r\n\r\n## Building an HTTP response\r\n\r\nKelp contains an elegant module, called [Kelp::Response](http://search.cpan.org/perldoc?Kelp::Response), which extends\r\n`Plack::Response` with several useful methods. Most methods return `$self`\r\nafter they do the required job.\r\nFor the sake of the examples below, let's assume that all of the code is located\r\ninside a route definition.\r\n\r\n### Automatic content type\r\n\r\nYour routes don't always have to set the `response` object. You could just\r\nreturn a simple scalar value or a reference to a hash, array or anything that\r\ncan be converted to JSON.\r\n\r\n```perl\r\n# Content-type automatically set to \"text/html\"\r\nsub text_route {\r\n    return \"There, there ...\";\r\n}\r\n\r\n# Content-type automatically set to \"application/json\"\r\nsub json_route {\r\n    return { error => 1,  message => \"Fail\" };\r\n}\r\n```\r\n\r\n### Rendering text\r\n\r\n```perl\r\n# Render simple text\r\n$self->res->text->render(\"It works!\");\r\n```\r\n\r\n### Rendering HTML\r\n\r\n```perl\r\n$self->res->html->render(\"<h1>It works!</h1>\");\r\n```\r\n\r\n### Custom content type\r\n\r\n```perl\r\n$self->res->set_content_type('image/png');\r\n```\r\n\r\n### Return 404 or 500 errors\r\n\r\n```perl\r\nsub some_route {\r\n    my $self = shift;\r\n    if ($missing) {\r\n        return $self->res->render_404;\r\n    }\r\n    if ($broken) {\r\n        return $self->res->render_500;\r\n    }\r\n}\r\n```\r\n\r\n### Templates\r\n\r\n```perl\r\nsub hello {\r\n    my ( $self, $name ) = @_;\r\n    $self->res->template( 'hello.tt', { name => $name } );\r\n}\r\n```\r\n\r\nThe above example will render the contents of `hello.tt`, and it will set the\r\ncontent-type to `text/html`. To set a different content-type, use\r\n`set_content_type` or any of its aliases:\r\n\r\n```perl\r\nsub hello_txt {\r\n    my ( $self, $name ) = @_;\r\n    $self->res->text->template( 'hello_txt.tt', { name => $name } );\r\n}\r\n```\r\n\r\n### Headers\r\n\r\n```perl\r\n$self->set_header( \"X-Framework\", \"Kelp\" )->render( { success => \\1 } );\r\n```\r\n\r\n### Serving static files\r\n\r\nIf you want to serve static pages, you can use the [Plack::Middleware::Static](http://search.cpan.org/perldoc?Plack::Middleware::Static)\r\nmiddleware that comes with Plack. Here is an example configuration that serves\r\nfiles in your `public` folder (under the Kelp root folder) from URLs that\r\nbegin with `/public`:\r\n\r\n```perl\r\n# conf/config.pl\r\n{\r\n    middleware      => [qw/Static/],\r\n    middleware_init => {\r\n        Static => {\r\n            path => qr{^/public/},\r\n            root => '.',\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### Uploading files\r\n\r\nFile uploads are handled by [Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request), which inherits Plack::Request\r\nand has its `uploads|Plack::Request/uploads` property. The uploads propery returns a\r\nreference to a hash containing all uploads.\r\n\r\n```perl\r\nsub upload {\r\n    my $self = shift;\r\n    my $uploads  = $self->req->uploads;\r\n\r\n    # Now $uploads is a hashref to all uploads\r\n    ...\r\n}\r\n```\r\n\r\nFor [Kelp::Less](http://search.cpan.org/perldoc?Kelp::Less), then you can use the `req` reserved word:\r\n\r\n```perl\r\nget '/upload' => sub {\r\n    my $uploads = req->uploads;\r\n};\r\n```\r\n\r\n### Delayed responses\r\n\r\nTo send a delayed response, have your route return a subroutine.\r\n\r\n```perl\r\nsub delayed {\r\n    my $self = shift;\r\n    return sub {\r\n        my $responder = shift;\r\n        $self->res->code(200);\r\n        $self->res->text->body(\"Better late than never.\");\r\n        $responder->($self->res->finalize);\r\n    };\r\n}\r\n```\r\n\r\nSee the [PSGI](http://search.cpan.org/perldoc?PSGI#Delayed-Response-and-Streaming-Body) pod for more\r\ninformation and examples.\r\n\r\n## Pluggable modules\r\n\r\nKelp can be extended using custom _modules_. Each new module must be a subclass\r\nof the `Kelp::Module` namespace. Modules' job is to initialize and register new\r\nmethods into the web application class. The following is the full code of the\r\n[Kelp::Module::JSON](http://search.cpan.org/perldoc?Kelp::Module::JSON) for example:\r\n\r\n```perl\r\npackage Kelp::Module::JSON;\r\n\r\nuse Kelp::Base 'Kelp::Module';\r\nuse JSON;\r\n\r\nsub build {\r\n    my ( $self, %args ) = @_;\r\n    my $json = JSON->new;\r\n    $json->property( $_ => $args{$_} ) for keys %args;\r\n    $self->register( json => $json );\r\n}\r\n\r\n1;\r\n```\r\n\r\nWhat is happening here?\r\n\r\n- First we create a class `Kelp::Module::JSON` which inherits `Kelp::Module`.\r\n- Then, we override the `build` method (of `Kelp::Module`), create a new JSON\r\nobject and register it into the web application via the `register` method.\r\n\r\nIf we instruct our web application to load the `JSON` module, it will have a\r\nnew method `json` which will be a link to the `JSON` object initialized in the\r\nmodule.\r\n\r\nSee more exampled and POD at [Kelp::Module](http://search.cpan.org/perldoc?Kelp::Module).\r\n\r\n### How to load modules using the config\r\n\r\nThere are two modules that are __always__ loaded by each application instance.\r\nThose are `Config` and `Routes`. The reason behind this is that each and every\r\napplication always needs a router and configuration.\r\nAll other modules must be loaded either using the [\"load\\_module\"](#load\\_module) method, or\r\nusing the `modules` key in the configuration. The default configuration already\r\nloads these modules: `Template`, `Logger` and `JSON`. Your configuration can\r\nremove some and/or add others. The configuration key `modules_init` may contain\r\nhashes with initialization arguments. See [Kelp::Module](http://search.cpan.org/perldoc?Kelp::Module) for configuration\r\nexamples.\r\n\r\n# ATTRIBUTES\r\n\r\n## hostname\r\n\r\nGets the current hostname.\r\n\r\n```perl\r\nsub some_route {\r\n    my $self = shift;\r\n    if ( $self->hostname eq 'prod-host' ) {\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n## mode\r\n\r\nSets or gets the current mode. The mode is important for the app to know what\r\nconfiguration file to merge into the main configuration. See\r\n[Kelp::Module::Config](http://search.cpan.org/perldoc?Kelp::Module::Config) for more information.\r\n\r\n```perl\r\nmy $app = MyApp->new( mode => 'development' );\r\n# conf/config.pl and conf/development.pl are merged with priority\r\n# given to the second one.\r\n```\r\n\r\n## config\\_module\r\n\r\nSets of gets the class of the configuration module to be loaded on startup. The\r\ndefault value is `Config`, which will cause the `Kelp::Module::Config` to get\r\nloaded. See the documentation for [Kelp::Module::Config](http://search.cpan.org/perldoc?Kelp::Module::Config) for more information\r\nand for an example of how to create and use other config modules.\r\n\r\n## path\r\n\r\nGets the current path of the application. That would be the path to `app.psgi`\r\n\r\n## name\r\n\r\nGets or sets the name of the application. If not set, the name of the main\r\nclass will be used.\r\n\r\n```perl\r\nmy $app = MyApp->new( name => 'Twittar' );\r\n```\r\n\r\n## charset\r\n\r\nSets of gets the encoding charset of the app. It will be `UTF-8`, if not set to\r\nanything else. The charset could also be changed in the config files.\r\n\r\n## req\r\n\r\nThis attribute only makes sense if called within a route definition. It will\r\ncontain a reference to the current [Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request) instance.\r\n\r\n```perl\r\nsub some_route {\r\n    my $self = shift;\r\n    if ( $self->req->is_json ) {\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n## res\r\n\r\nThis attribute only makes sense if called within a route definition. It will\r\ncontain a reference to the current [Kelp::Response](http://search.cpan.org/perldoc?Kelp::Response) instance.\r\n\r\n```perl\r\nsub some_route {\r\n    my $self = shift;\r\n    $self->res->json->render( { success => 1 } );\r\n}\r\n```\r\n\r\n# METHODS\r\n\r\n## build\r\n\r\nOn it's own the `build` method doesn't do anything. It is called by the\r\nconstructor, so it can be overridden to add route destinations and\r\ninitializations.\r\n\r\n```perl\r\npackage MyApp;\r\n\r\nsub build {\r\n    my $self = shift;\r\n    my $r = $self->routes;\r\n\r\n    # Load some modules\r\n    $self->load_module(\"MongoDB\");\r\n    $self->load_module(\"Validate\");\r\n\r\n    # Add all route destinations\r\n    $r->add(\"/one\", \"one\");\r\n    ...\r\n\r\n}\r\n```\r\n\r\n## load\\_module\r\n\r\n`load_module($name, %options)`\r\n\r\nUsed to load a module. All modules must be under the `Kelp::Module::`\r\nnamespace.\r\n\r\n```perl\r\n$self->load_module(\"Redis\", server => '127.0.0.1');\r\n# Will look for and load Kelp::Module::Redis\r\n```\r\n\r\nOptions for the module may be specified after its name, or in the\r\n`modules_init` hash in the config. The precedence is given to the\r\ninline options.\r\nSee [Kelp::Module](http://search.cpan.org/perldoc?Kelp::Module) for more information on making and using modules.\r\n\r\n## request\r\n\r\nThis method is used to create the request object for each HTTP request. It\r\nreturns an instance of [Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request), initialized with the current request's\r\nenvironment. You can override this method to use a custom request module.\r\n\r\n```perl\r\npackage MyApp;\r\nuse MyApp::Request;\r\n\r\nsub request {\r\n    my ( $self, $env ) = @_;\r\n    return MyApp::Requst->new( app => $app, env => $env );\r\n}\r\n\r\n# Now each request will be handled by MyApp::Request\r\n```\r\n\r\n## before\\_render\r\n\r\nOverride this method, to modify the response object just before it gets\r\nrendered.\r\n\r\n```perl\r\npackage MyApp;\r\n\r\nsub before_render {\r\n    my $self = shift;\r\n    $self->res->set_header(\"X-App-Name\", \"MyApp\");\r\n}\r\n\r\n...\r\n```\r\n\r\nThe above is an example of how to insert a custom header into the response of\r\nevery route.\r\n\r\n## response\r\n\r\nThis method creates the response object, e.g. what an HTTP request will return.\r\nBy default the object created is [Kelp::Response](http://search.cpan.org/perldoc?Kelp::Response). Much like [\"request\"](#request), the\r\nresponse can also be overridden to use a custom response object.\r\n\r\n## run\r\n\r\nThis method builds and returns the PSGI app. You can override it in order to\r\ninclude middleware. See [\"Adding middleware\"](#Adding middleware) for an example.\r\n\r\n## param\r\n\r\nA shortcut to `$self->req->param`:\r\n\r\n```perl\r\nsub some_route {\r\n    my $self = shift;\r\n    if ( $self->param('age') > 18 ) {\r\n        $self->can_watch_south_path(1);\r\n    }\r\n}\r\n```\r\n\r\nSee [Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request) for more information and examples.\r\n\r\n## stash\r\n\r\nProvides safe access to `$self->req->stash`. When called without\r\narguments, it will return the stash hash. If called with a single argument, it\r\nwill return the value of the corresponding key in the stash.\r\nSee [\"stash\" in Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request#stash) for more information and examples.\r\n\r\n## named\r\n\r\nProvides safe access to `$self->req->named`. When called without\r\narguments, it will return the named hash. If called with a single argument, it\r\nwill return the value of the corresponding key in the named hash.\r\nSee [\"named\" in Kelp::Request](http://search.cpan.org/perldoc?Kelp::Request#named) for more information and examples.\r\n\r\n## url\\_for\r\n\r\nA safe shortcut to `$self->routes->url`. Builds a URL from path and\r\narguments.\r\n\r\n```perl\r\nsub build {\r\n    my $self = shift;\r\n    $self->routes->add(\"/:name/:id\", { name => 'name', to => sub {\r\n        ...\r\n    }});\r\n}\r\n\r\nsub check {\r\n    my $self = shift;\r\n    my $url_for_name = $self->url_for('name', name => 'jake', id => 1003);\r\n    $self->res->redirect_to( $url_for_name );\r\n}\r\n```\r\n\r\n# SUPPORT\r\n\r\n- GitHub: https://github.com/naturalist/kelp\r\n- Mailing list: https://groups.google.com/forum/?fromgroups\\#!forum/perl-kelp\r\n\r\n# AUTHOR\r\n\r\nStefan Geneshky - minimal@cpan.org\r\n\r\n# CONTRIBUTORS\r\n\r\nGurunandan Bhat - gbhat@pobox.com\r\n\r\n# LICENSE\r\n\r\nThis module and all the modules in this package are governed by the same license\r\nas Perl itself.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}